class CPU:
    # ... (Konstruktor, Register, Flags, Hilfsfunktionen wie zuvor)

    def execute_instruction(self):
        opcode = self.memory[self.pc]
        self.pc += 1

        # ... (Adressierungsmodi wie zuvor)

        # Opcode-Implementierungen
        if opcode == 0xA9:  # LDA (immediate)
            value = self.memory[immediate()]
            self.a = value
            self.set_zn_flags(self.a)
        elif opcode == 0xA5:  # LDA (zero page)
            address = zero_page()
            self.a = self.memory[address]
            self.set_zn_flags(self.a)
        elif opcode == 0xB5:  # LDA (zero page,X)
            address = zero_page_x()
            self.a = self.memory[address]
            self.set_zn_flags(self.a)
        elif opcode == 0xAD:  # LDA (absolute)
            address = absolute()
            self.a = self.memory[address]
            self.set_zn_flags(self.a)
        elif opcode == 0xBD:  # LDA (absolute,X)
            address = absolute_x()
            self.a = self.memory[address]
            self.set_zn_flags(self.a)
        elif opcode == 0xB9:  # LDA (absolute,Y)
            address = absolute_y()
            self.a = self.memory[address]
            self.set_zn_flags(self.a)
        elif opcode == 0xA1:  # LDA (indirect,X)
            address = indirect_x()
            self.a = self.memory[address]
            self.set_zn_flags(self.a)
        elif opcode == 0xB1:  # LDA (indirect),Y
            address = indirect_y()
            self.a = self.memory[address]
            self.set_zn_flags(self.a)

        elif opcode == 0xA2:  # LDX (immediate)
            self.x = self.memory[immediate()]
            self.set_zn_flags(self.x)
        elif opcode == 0xA6:  # LDX (zero page)
            address = zero_page()
            self.x = self.memory[address]
            self.set_zn_flags(self.x)
        elif opcode == 0xB6:  # LDX (zero page,Y)
            address = zero_page_y()
            self.x = self.memory[address]
            self.set_zn_flags(self.x)
        elif opcode == 0xAE:  # LDX (absolute)
            address = absolute()
            self.x = self.memory[address]
            self.set_zn_flags(self.x)
        elif opcode == 0xBE:  # LDX (absolute,Y)
            address = absolute_y()
            self.x = self.memory[address]
            self.set_zn_flags(self.x)

        elif opcode == 0xA0:  # LDY (immediate)
            self.y = self.memory[immediate()]
            self.set_zn_flags(self.y)
        elif opcode == 0xA4:  # LDY (zero page)
            address = zero_page()
            self.y = self.memory[address]
            self.set_zn_flags(self.y)
        elif opcode == 0xB4:  # LDY (zero page,X)
            address = zero_page_x()
            self.y = self.memory[address]
            self.set_zn_flags(self.y)
        elif opcode == 0xAC:  # LDY (absolute)
            address = absolute()
            self.y = self.memory[address]
            self.set_zn_flags(self.y)
        elif opcode == 0xBC:  # LDY (absolute,X)
            address = absolute_x()
            self.y = self.memory[address]
            self.set_zn_flags(self.y)

        elif opcode == 0x85:  # STA (zero page)
            address = zero_page()
            self.memory[address] = self.a
        elif opcode == 0x95:  # STA (zero page,X)
            address = zero_page_x()
            self.memory[address] = self.a
        elif opcode == 0x8D:  # STA (absolute)
            address = absolute()
            self.memory[address] = self.a
        elif opcode == 0x9D:  # STA (absolute,X)
            address = absolute_x()
            self.memory[address] = self.a
        elif opcode == 0x99:  # STA (absolute,Y)
            address = absolute_y()
            self.memory[address] = self.a
        elif opcode == 0x81:  # STA (indirect,X)
            address = indirect_x()
            self.memory[address] = self.a
        elif opcode == 0x91:  # STA (indirect),Y
            address = indirect_y()
            self.memory[address] = self.a

        elif opcode == 0x86:  # STX (zero page)
            address = zero_page()
            self.memory[address] = self.x
        elif opcode == 0x96:  # STX (zero page,Y)
            address = zero_page_y()
            self.memory[address] = self.x
        elif opcode == 0x8E:  # STX (absolute)
            address = absolute()
            self.memory[address] = self.x

        elif opcode == 0x84:  # STY (zero page)
            address = zero_page()
            self.memory[address] = self.y
        elif opcode == 0x94:  # STY (zero page,X)
            address = zero_page_x()
            self.memory[address] = self.y
        elif opcode == 0x8C:  # STY (absolute)
            address = absolute()
            self.memory[address] = self.y

        elif opcode == 0x64:  # STZ (zero page)
            address = zero_page()
            self.memory[address] = 0
            self.set_zn_flags(0)  # Z-Flag setzen
        elif opcode == 0x9C:  # STZ (absolute)
            address = absolute()
            self.memory[address] = 0
            self.set_zn_flags(0)  # Z-Flag setzen

        elif opcode == 0xAA:  # TAX
            self.x = self.a
            self.set_zn_flags(self.x)
        elif opcode == 0xA8:  # TAY
            self.y = self.a
            self.set_zn_flags(self.y)
        elif opcode == 0x8A:  # TXA
            self.a = self.x
            self.set_zn_flags(self.a)
        elif opcode == 0x98:  # TYA
            self.a = self.y
            self.set_zn_flags(self.a)
        elif opcode == 0xBA:  # TSX
            self.x = self.s
            self.set_zn_flags(self.x)
        elif opcode == 0x9A:  # TXS
            self.s = self.x
            # TXS setzt keine Flags
        
        # ... (LDA, LDX, LDY, STA, STX, STY, STZ, TAX, TAY, TXA, TYA, TSX, TXS Opcodes aus Teil 1 und 2)

        elif opcode == 0xE6:  # INC (zero page)
            address = zero_page()
            self.memory[address] = (self.memory[address] + 1) & 0xFF
            self.set_zn_flags(self.memory[address])
        elif opcode == 0xF6:  # INC (zero page,X)
            address = zero_page_x()
            self.memory[address] = (self.memory[address] + 1) & 0xFF
            self.set_zn_flags(self.memory[address])
        elif opcode == 0xEE:  # INC (absolute)
            address = absolute()
            self.memory[address] = (self.memory[address] + 1) & 0xFF
            self.set_zn_flags(self.memory[address])
        elif opcode == 0xFE:  # INC (absolute,X)
            address = absolute_x()
            self.memory[address] = (self.memory[address] + 1) & 0xFF
            self.set_zn_flags(self.memory[address])

        elif opcode == 0xE8:  # INX
            self.x = (self.x + 1) & 0xFF
            self.set_zn_flags(self.x)
        elif opcode == 0xC8:  # INY
            self.y = (self.y + 1) & 0xFF
            self.set_zn_flags(self.y)

        elif opcode == 0xC6:  # DEC (zero page)
            address = zero_page()
            self.memory[address] = (self.memory[address] - 1) & 0xFF
            self.set_zn_flags(self.memory[address])
        elif opcode == 0xD6:  # DEC (zero page,X)
            address = zero_page_x()
            self.memory[address] = (self.memory[address] - 1) & 0xFF
            self.set_zn_flags(self.memory[address])
        elif opcode == 0xCE:  # DEC (absolute)
            address = absolute()
            self.memory[address] = (self.memory[address] - 1) & 0xFF
            self.set_zn_flags(self.memory[address])
        elif opcode == 0xDE:  # DEC (absolute,X)
            address = absolute_x()
            self.memory[address] = (self.memory[address] - 1) & 0xFF
            self.set_zn_flags(self.memory[address])

        elif opcode == 0xCA:  # DEX
            self.x = (self.x - 1) & 0xFF
            self.set_zn_flags(self.x)
        elif opcode == 0x88:  # DEY
            self.y = (self.y - 1) & 0xFF
            self.set_zn_flags(self.y)
        # ... (LDA, LDX, LDY, STA, STX, STY, STZ, TAX, TAY, TXA, TYA, TSX, TXS, INC, INX, INY, DEC, DEX, DEY Opcodes aus Teil 1, 2 und 3)

        elif opcode == 0x0A:  # ASL (Akkumulator)
            self.c_flag = self.a >> 7
            self.a = (self.a << 1) & 0xFF
            self.set_zn_flags(self.a)
        elif opcode == 0x06:  # ASL (zero page)
            address = zero_page()
            value = self.memory[address]
            self.c_flag = value >> 7
            self.memory[address] = (value << 1) & 0xFF
            self.set_zn_flags(self.memory[address])
        # ... (ASL zero page,X, absolute, absolute,X)

        elif opcode == 0x4A:  # LSR (Akkumulator)
            self.c_flag = self.a & 0x01
            self.a >>= 1
            self.set_zn_flags(self.a)
        elif opcode == 0x46:  # LSR (zero page)
            address = zero_page()
            value = self.memory[address]
            self.c_flag = value & 0x01
            self.memory[address] = value >> 1
            self.set_zn_flags(self.memory[address])
        # ... (LSR zero page,X, absolute, absolute,X)

        elif opcode == 0x2A:  # ROL (Akkumulator)
            old_carry = self.c_flag
            self.c_flag = self.a >> 7
            self.a = ((self.a << 1) | old_carry) & 0xFF
            self.set_zn_flags(self.a)
        elif opcode == 0x26:  # ROL (zero page)
            address = zero_page()
            value = self.memory[address]
            old_carry = self.c_flag
            self.c_flag = value >> 7
            self.memory[address] = ((value << 1) | old_carry) & 0xFF
            self.set_zn_flags(self.memory[address])
        # ... (ROL zero page,X, absolute, absolute,X)

        elif opcode == 0x6A:  # ROR (Akkumulator)
            old_carry = self.c_flag
            self.c_flag = self.a & 0x01
            self.a = (self.a >> 1) | (old_carry << 7)
            self.set_zn_flags(self.a)
        elif opcode == 0x66:  # ROR (zero page)
            address = zero_page()
            value = self.memory[address]
            old_carry = self.c_flag
            self.c_flag = value & 0x01
            self.memory[address] = (value >> 1) | (old_carry << 7)
            self.set_zn_flags(self.memory[address])
        # ... (ROR zero page,X, absolute, absolute,X)

        elif opcode == 0x29:  # AND (immediate)
            self.a &= self.memory[immediate()]
            self.set_zn_flags(self.a)
        # ... (AND zero page, zero page,X, absolute, absolute,X, absolute,Y, indirect,X, indirect,Y)

        elif opcode == 0x49:  # EOR (immediate)
            self.a ^= self.memory[immediate()]
            self.set_zn_flags(self.a)
        # ... (EOR zero page, zero page,X, absolute, absolute,X, absolute,Y, indirect,X, indirect,Y)

        elif opcode == 0x09:  # ORA (immediate)
            self.a |= self.memory[immediate()]
            self.set_zn_flags(self.a)
        # ... (ORA zero page, zero page,X, absolute, absolute,X, absolute,Y, indirect,X, indirect,Y)
        
        # ... (Fortsetzung in Teil 5)
        # ... (LDA, LDX, LDY, STA, STX, STY, STZ, TAX, TAY, TXA, TYA, TSX, TXS, INC, INX, INY, DEC, DEX, DEY, ASL, LSR, ROL, ROR, AND, EOR, ORA Opcodes aus Teil 1, 2, 3 und 4)

        elif opcode == 0x24:  # BIT (zero page)
            address = zero_page()
            value = self.memory[address]
            self.set_flag(0x02, (self.a & value) == 0)  # Zero Flag
            self.set_flag(0x80, value & 0x80 != 0)  # Negative Flag
            self.set_flag(0x40, value & 0x40 != 0)  # Overflow Flag
        # ... (BIT absolute)

        elif opcode == 0xC9:  # CMP (immediate)
            value = self.memory[immediate()]
            result = self.a - value
            self.set_flag(0x01, result >= 0)  # Carry Flag
            self.set_zn_flags(result & 0xFF)
        # ... (CMP zero page, zero page,X, absolute, absolute,X, absolute,Y, indirect,X, indirect,Y)

        elif opcode == 0xE0:  # CPX (immediate)
            value = self.memory[immediate()]
            result = self.x - value
            self.set_flag(0x01, result >= 0)  # Carry Flag
            self.set_zn_flags(result & 0xFF)
        # ... (CPX zero page, absolute)

        elif opcode == 0xC0:  # CPY (immediate)
            value = self.memory[immediate()]
            result = self.y - value
            self.set_flag(0x01, result >= 0)  # Carry Flag
            self.set_zn_flags(result & 0xFF)
        # ... (CPY zero page, absolute)

        elif opcode == 0x4C:  # JMP (absolute)
            self.pc = absolute()
        elif opcode == 0x6C:  # JMP (indirect)
            address = absolute()
            self.pc = (self.memory[address + 1] << 8) | self.memory[address]

        elif opcode == 0x20:  # JSR
            address = absolute()
            self.push_stack((self.pc - 1) >> 8)
            self.push_stack((self.pc - 1) & 0xFF)
            self.pc = address

        elif opcode == 0x60:  # RTS
            low_byte = pop_stack()
            high_byte = pop_stack()
            self.pc = (high_byte << 8) | low_byte
            self.pc += 1

        elif opcode == 0x40:  # RTI
            self.p = pop_stack()
            low_byte = pop_stack()
            high_byte = pop_stack()
            self.pc = (high_byte << 8) | low_byte

        elif opcode == 0x90:  # BCC
            if not self.c_flag:
                self.pc = relative()
        elif opcode == 0xB0:  # BCS
            if self.c_flag:
                self.pc = relative()
        elif opcode == 0xF0:  # BEQ
            if self.z_flag:
                self.pc = relative()
        # ... (BNE, BMI, BPL, BVC, BVS ähnlich)

        # ... (Fortsetzung in Teil 6)
        # ... (LDA, LDX, LDY, STA, STX, STY, STZ, TAX, TAY, TXA, TYA, TSX, TXS, INC, INX, INY, DEC, DEX, DEY, ASL, LSR, ROL, ROR, AND, EOR, ORA, BIT, CMP, CPX, CPY, JMP, JSR, RTS, RTI, BCC, BCS, BEQ, BNE, BMI, BPL, BVC, BVS Opcodes aus Teil 1, 2, 3, 4 und 5)

        elif opcode == 0x18:  # CLC
            self.c_flag = 0
        elif opcode == 0x38:  # SEC
            self.c_flag = 1
        elif opcode == 0x58:  # CLI
            self.i_flag = 0
        elif opcode == 0x78:  # SEI
            self.i_flag = 1
        elif opcode == 0xB8:  # CLV
            self.v_flag = 0
        elif opcode == 0xD8:  # CLD
            self.d_flag = 0
        elif opcode == 0xF8:  # SED
            self.d_flag = 1

        elif opcode == 0x00:  # BRK
            self.pc += 1
            self.push_stack(self.pc >> 8)
            self.push_stack(self.pc & 0xFF)
            self.push_stack(self.p | 0x10)  # Setze Break-Flag
            self.i_flag = 1  # Interrupts deaktivieren
            self.pc = (self.memory[0xFFFE] << 8) | self.memory[0xFFFF]

        # NOP-Befehle
        elif opcode in (0xEA, 0x1A, 0x3A, 0x5A, 0x7A, 0xDA, 0xFA):  # NOP
            pass

        # JMP (absolute)
        elif opcode == 0x4C:  # JMP (absolute)
            self.pc = absolute()
        elif opcode == 0x6C:  # JMP (indirect)
            address = absolute()
            self.pc = (self.memory[address + 1] << 8) | self.memory[address]

        # ... (Fortsetzung in Teil 7)
# ... (Opcodes aus Teil 1-6)

        elif opcode == 0x69:  # ADC (immediate)
            value = self.memory[immediate()]
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 == 0) and ((self.a ^ result) & 0x80 != 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (ADC zero page, zero page,X, absolute, absolute,X, absolute,Y, indirect,X, indirect,Y)

        elif opcode == 0xE9 or opcode == 0xEB:  # SBC (immediate)
            value = self.memory[immediate()] ^ 0xFF  # Komplement für Subtraktion
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 != 0) and ((self.a ^ result) & 0x80 == 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (SBC zero page, zero page,X, absolute, absolute,X, absolute,Y, indirect,X, indirect,Y)

        # ... (INC, INX, INY, DEC, DEX, DEY Opcodes aus Teil 3)

        # Ungewöhnliche Opcodes (DCP, ISC, SLO, RLA, SRE, RRA)
        elif opcode == 0xC3:  # DCP (indirect,X)
            address = indirect_x()
            value = (self.memory[address] - 1) & 0xFF
            self.memory[address] = value
            self.set_zn_flags(self.a - value)
        # ... (DCP für andere Adressierungsmodi)

        elif opcode == 0xE3:  # ISC (indirect,X)
            address = indirect_x()
            value = (self.memory[address] + 1) & 0xFF
            self.memory[address] = value
            result = self.a - value - (1 - self.c_flag)
            self.a = result & 0xFF
            self.set_flag(0x01, result >= 0)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 != 0) and ((self.a ^ result) & 0x80 == 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (ISC für andere Adressierungsmodi)

        elif opcode == 0x03:  # SLO (indirect,X)
            address = indirect_x()
            value = self.memory[address]
            self.c_flag = value >> 7
            value = (value << 1) & 0xFF
            self.memory[address] = value
            self.a |= value
            self.set_zn_flags(self.a)
        # ... (SLO für andere Adressierungsmodi)

        # ... (RLA, SRE, RRA ähnlich wie SLO, ISC, DCP)


        # ... (Fortsetzung in Teil 8)
# ... (Opcodes aus Teil 1-7)

        # RLA (Rotate Left, then AND with accumulator)
        elif opcode == 0x23:  # RLA (indirect,X)
            address = indirect_x()
            value = self.memory[address]
            old_carry = self.c_flag
            self.c_flag = value >> 7
            value = ((value << 1) | old_carry) & 0xFF
            self.memory[address] = value
            self.a &= value
            self.set_zn_flags(self.a)
        # ... (RLA für andere Adressierungsmodi)

        # SRE (Shift Right, then Exclusive OR with accumulator)
        elif opcode == 0x43:  # SRE (indirect,X)
            address = indirect_x()
            value = self.memory[address]
            self.c_flag = value & 0x01
            value >>= 1
            self.memory[address] = value
            self.a ^= value
            self.set_zn_flags(self.a)
        # ... (SRE für andere Adressierungsmodi)

        # RRA (Rotate Right, then Add with Carry to accumulator)
        elif opcode == 0x63:  # RRA (indirect,X)
            address = indirect_x()
            value = self.memory[address]
            old_carry = self.c_flag
            self.c_flag = value & 0x01
            value = (value >> 1) | (old_carry << 7)
            self.memory[address] = value
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 == 0) and ((self.a ^ result) & 0x80 != 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (RRA für andere Adressierungsmodi)

        # SAX (Store A AND X)
        elif opcode == 0x83:  # SAX (indirect,X)
            address = indirect_x()
            self.memory[address] = self.a & self.x
        # ... (SAX für andere Adressierungsmodi)

        # LAX (Load A and X)
        elif opcode == 0xA3:  # LAX (indirect,X)
            address = indirect_x()
            value = self.memory[address]
            self.a = value
            self.x = value
            self.set_zn_flags(value)
        # ... (LAX für andere Adressierungsmodi)

        # DCP (Decrement and Compare with accumulator)
        elif opcode == 0xC3:  # DCP (indirect,X)
            address = indirect_x()
            value = (self.memory[address] - 1) & 0xFF
            self.memory[address] = value
            self.set_zn_flags(self.a - value)
        # ... (DCP für andere Adressierungsmodi)

        # AXS (AND X with accumulator, then Store)
        elif opcode == 0xCB:  # AXS (immediate)
            value = self.memory[immediate()]
            self.x = (self.a & self.x) - value
            self.set_flag(0x01, self.x >= 0)  # Carry Flag
            self.set_zn_flags(self.x & 0xFF)

        # ANC (AND with accumulator, then set Carry flag to Negative flag)
        elif opcode == 0x0B or opcode == 0x2B:  # ANC (immediate)
            value = self.memory[immediate()]
            self.a &= value
            self.set_flag(0x01, self.n_flag)  # Carry Flag = Negative Flag
            self.set_zn_flags(self.a)

        # ALR (AND with accumulator, then shift Right)
        elif opcode == 0x4B:  # ALR (immediate)
            value = self.memory[immediate()]
            self.a &= value
            self.set_flag(0x01, self.a & 0x01)  # Carry Flag = Bit 0 of accumulator
            self.a >>= 1
            self.set_zn_flags(self.a)

        # ARR (AND with accumulator, then Rotate Right)
        elif opcode == 0x6B:  # ARR (immediate)
            value = self.memory[immediate()]
            self.a &= value
            old_carry = self.c_flag
            self.c_flag = self.a & 0x01
            self.a = (self.a >> 1) | (old_carry << 7)

            # Set flags (specific to ARR)
            self.set_flag(0x40, (self.a & 0x40) ^ (self.a & 0x20))  # Overflow Flag
            self.set_zn_flags(self.a)

        # ... (Fortsetzung in Teil 9)
# ... (Opcodes aus Teil 1-8)

        # Branch-Befehle (relative Adressierung)
        elif opcode == 0x90:  # BCC (Branch if Carry Clear)
            if not self.get_flag(0x01):
                self.pc = relative()
        elif opcode == 0xB0:  # BCS (Branch if Carry Set)
            if self.get_flag(0x01):
                self.pc = relative()
        elif opcode == 0xF0:  # BEQ (Branch if Equal)
            if self.get_flag(0x02):
                self.pc = relative()
        elif opcode == 0xD0:  # BNE (Branch if Not Equal)
            if not self.get_flag(0x02):
                self.pc = relative()
        elif opcode == 0x30:  # BMI (Branch if Minus)
            if self.get_flag(0x80):
                self.pc = relative()
        elif opcode == 0x10:  # BPL (Branch if Positive)
            if not self.get_flag(0x80):
                self.pc = relative()
        elif opcode == 0x50:  # BVC (Branch if Overflow Clear)
            if not self.get_flag(0x40):
                self.pc = relative()
        elif opcode == 0x70:  # BVS (Branch if Overflow Set)
            if self.get_flag(0x40):
                self.pc = relative()

        # Stack-Befehle
        elif opcode == 0x48:  # PHA
            push_stack(self.a)
        elif opcode == 0x68:  # PLA
            self.a = pop_stack()
            self.set_zn_flags(self.a)
        elif opcode == 0x08:  # PHP
            push_stack(self.p | 0x10 | 0x20)  # Break and unused flags gesetzt
        elif opcode == 0x28:  # PLP
            self.p = pop_stack() & 0xEF | 0x20  # Break-Flag löschen

        # Flag-Befehle
        elif opcode == 0x18:  # CLC
            self.set_flag(0x01, False)  # Carry Flag löschen
        elif opcode == 0x38:  # SEC
            self.set_flag(0x01, True)  # Carry Flag setzen
        elif opcode == 0x58:  # CLI
            self.set_flag(0x04, False)  # Interrupt Disable Flag löschen
        elif opcode == 0x78:  # SEI
            self.set_flag(0x04, True)  # Interrupt Disable Flag setzen
        elif opcode == 0xB8:  # CLV
            self.set_flag(0x40, False)  # Overflow Flag löschen
        elif opcode == 0xD8:  # CLD
            self.set_flag(0x08, False)  # Decimal Mode Flag löschen
        elif opcode == 0xF8:  # SED
            self.set_flag(0x08, True)  # Decimal Mode Flag setzen

        # XCE (Exchange Carry and Emulation flags)
        elif opcode == 0xFB:  
            temp = self.c_flag
            self.c_flag = self.emulation_mode
            self.emulation_mode = temp

        # WDM (Reserved for future expansion)
        elif opcode == 0x42:
            pass  # Nicht implementiert

        # ... (Fortsetzung in Teil 10)
# ... (Opcodes aus Teil 1-9)

        # ORA (OR with Accumulator)
        elif opcode == 0x09:  # ORA (immediate)
            self.a |= self.memory[immediate()]
            self.set_zn_flags(self.a)
        elif opcode == 0x05:  # ORA (zero page)
            self.a |= self.memory[zero_page()]
            self.set_zn_flags(self.a)
        elif opcode == 0x15:  # ORA (zero page,X)
            self.a |= self.memory[zero_page_x()]
            self.set_zn_flags(self.a)
        elif opcode == 0x0D:  # ORA (absolute)
            self.a |= self.memory[absolute()]
            self.set_zn_flags(self.a)
        elif opcode == 0x1D:  # ORA (absolute,X)
            self.a |= self.memory[absolute_x()]
            self.set_zn_flags(self.a)
        elif opcode == 0x19:  # ORA (absolute,Y)
            self.a |= self.memory[absolute_y()]
            self.set_zn_flags(self.a)
        elif opcode == 0x01:  # ORA (indirect,X)
            self.a |= self.memory[indirect_x()]
            self.set_zn_flags(self.a)
        elif opcode == 0x11:  # ORA (indirect),Y
            self.a |= self.memory[indirect_y()]
            self.set_zn_flags(self.a)

        # AND (AND with Accumulator)
        elif opcode == 0x29:  # AND (immediate)
            self.a &= self.memory[immediate()]
            self.set_zn_flags(self.a)
        elif opcode == 0x25:  # AND (zero page)
            self.a &= self.memory[zero_page()]
            self.set_zn_flags(self.a)
        # ... (AND für andere Adressierungsmodi)

        # EOR (Exclusive OR with Accumulator)
        elif opcode == 0x49:  # EOR (immediate)
            self.a ^= self.memory[immediate()]
            self.set_zn_flags(self.a)
        elif opcode == 0x45:  # EOR (zero page)
            self.a ^= self.memory[zero_page()]
            self.set_zn_flags(self.a)
        # ... (EOR für andere Adressierungsmodi)

        # ADC (Add with Carry)
        elif opcode == 0x69:  # ADC (immediate)
            value = self.memory[immediate()]
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 == 0) and ((self.a ^ result) & 0x80 != 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        elif opcode == 0x65:  # ADC (zero page)
            value = self.memory[zero_page()]
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 == 0) and ((self.a ^ result) & 0x80 != 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (ADC für andere Adressierungsmodi)

        # SBC (Subtract with Carry)
        elif opcode == 0xE9 or opcode == 0xEB:  # SBC (immediate)
            value = self.memory[immediate()] ^ 0xFF  # Komplement für Subtraktion
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 != 0) and ((self.a ^ result) & 0x80 == 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (SBC für andere Adressierungsmodi)
        
        # ... (Fortsetzung in Teil 11)
# ... (Opcodes aus Teil 1-9)

        # CMP (Compare with Accumulator)
        elif opcode == 0xC9:  # CMP (immediate)
            value = self.memory[immediate()]
            result = self.a - value
            self.set_flag(0x01, result >= 0)  # Carry Flag
            self.set_zn_flags(result & 0xFF)
        elif opcode == 0xC5:  # CMP (zero page)
            address = zero_page()
            result = self.a - self.memory[address]
            self.set_flag(0x01, result >= 0)
            self.set_zn_flags(result & 0xFF)
        elif opcode == 0xD5:  # CMP (zero page,X)
            address = zero_page_x()
            result = self.a - self.memory[address]
            self.set_flag(0x01, result >= 0)
            self.set_zn_flags(result & 0xFF)
        # ... (CMP absolute, absolute,X, absolute,Y, indirect,X, indirect,Y)

        # CPX (Compare with X)
        elif opcode == 0xE0:  # CPX (immediate)
            value = self.memory[immediate()]
            result = self.x - value
            self.set_flag(0x01, result >= 0)  # Carry Flag
            self.set_zn_flags(result & 0xFF)
        # ... (CPX zero page, absolute)

        # CPY (Compare with Y)
        elif opcode == 0xC0:  # CPY (immediate)
            value = self.memory[immediate()]
            result = self.y - value
            self.set_flag(0x01, result >= 0)  # Carry Flag
            self.set_zn_flags(result & 0xFF)
        # ... (CPY zero page, absolute)

        # BIT (Test BITs)
        elif opcode == 0x24:  # BIT (zero page)
            address = zero_page()
            value = self.memory[address]
            result = self.a & value
            self.set_flag(0x02, result == 0)  # Zero Flag
            self.set_flag(0x80, value & 0x80)  # Negative Flag
            self.set_flag(0x40, value & 0x40)  # Overflow Flag
        elif opcode == 0x2C:  # BIT (absolute)
            address = absolute()
            value = self.memory[address]
            result = self.a & value
            self.set_flag(0x02, result == 0)
            self.set_flag(0x80, value & 0x80)
            self.set_flag(0x40, value & 0x40)

        # Test-Befehle
        elif opcode == 0x2F:  # BRA (Branch Always)
            self.pc = relative()
        elif opcode == 0x89:  # BIT (immediate)
            # Der immediate Modus wird hier nicht unterstützt.
            # Bei inoffiziellen Opcodes variieren die Implementierungen.
            # Oft wird der Wert einfach ignoriert.
            pass

        # ... (Fortsetzung in Teil 11)
# ... (Opcodes aus Teil 1-10)

        # Stack-relative Adressierung
        elif opcode == 0x61:  # ADC (indirect,X)
            address = indirect_x()
            value = self.memory[address]
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 == 0) and ((self.a ^ result) & 0x80 != 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (ADC (indirect),Y, AND (indirect,X), (indirect),Y, etc.)

        # Block Move-Befehle
        elif opcode == 0x54:  # MVN
            dest_bank = self.memory[immediate()]
            src_bank = self.memory[immediate()]
            count = self.memory[immediate()]
            for i in range(count + 1):
                self.memory[(dest_bank << 16) | self.y] = self.memory[(src_bank << 16) | self.x]
                self.y = (self.y + 1) & 0xFF
        elif opcode == 0x44:  # MVP
            dest_pos = self.memory[immediate()]
            src_pos = self.memory[immediate()]
            count = self.memory[immediate()]
            for i in range(count + 1):
                self.memory[dest_pos | self.a] = self.memory[src_pos | self.a]
                self.a = (self.a - 1) & 0xFF

        # Co-Prozessor-Befehle (nicht implementiert)
        elif opcode in range(0x00, 0x20) or opcode in range(0x40, 0x60) or opcode in range(0x80, 0xA0) or opcode in range(0xC0, 0xE0):
            pass  # Nicht implementiert

        # BCD-Arithmetik (nicht implementiert)
        elif opcode == 0xFB:  # XCE
            # ... (bereits in Teil 9 implementiert)
        elif opcode == 0x33:  # XBA
            temp = (self.a & 0x0F) << 4 | (self.a & 0xF0) >> 4
            self.a = temp
            self.set_zn_flags(self.a)

        # JSL (Jump to Subroutine Long)
        elif opcode == 0x22:
            low_byte = self.memory[self.pc]
            self.pc += 1
            mid_byte = self.memory[self.pc]
            self.pc += 1
            high_byte = self.memory[self.pc]
            self.pc += 1
            return_address = self.pc - 1
            self.push_stack(return_address >> 16)
            self.push_stack((return_address >> 8) & 0xFF)
            self.push_stack(return_address & 0xFF)
            self.pc = (high_byte << 16) | (mid_byte << 8) | low_byte

        # JSR (absolute,X)
        elif opcode == 0xFC:
            address = absolute_x()
            self.push_stack((self.pc - 1) >> 8)
            self.push_stack((self.pc - 1) & 0xFF)
            self.pc = address

        # ... (Fortsetzung in Teil 12)
# ... (Opcodes aus Teil 1-11)

        # Stack-Befehle
        elif opcode == 0x48:  # PHA
            self.push_stack(self.a)
        elif opcode == 0xDA:  # PHA (long)
            if not self.emulation_mode:
                self.push_stack(self.a >> 8)
            self.push_stack(self.a & 0xFF)
        elif opcode == 0x68:  # PLA
            self.a = self.pop_stack()
            self.set_zn_flags(self.a)
        elif opcode == 0xFA:  # PLA (long)
            if not self.emulation_mode:
                self.a = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.a = self.pop_stack()
            self.set_zn_flags(self.a)
        elif opcode == 0x08:  # PHP
            self.push_stack(self.p | 0x10 | 0x20)  # Break and unused flags gesetzt
        elif opcode == 0x28:  # PLP
            self.p = self.pop_stack() & 0xEF | 0x20  # Break-Flag löschen
        elif opcode == 0x5A:  # PHY (Push Y)
            if not self.emulation_mode:
                self.push_stack(self.y >> 8)
            self.push_stack(self.y & 0xFF)
        elif opcode == 0x7A:  # PLY (Pull Y)
            if not self.emulation_mode:
                self.y = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.y = self.pop_stack()
            self.set_zn_flags(self.y)
        elif opcode == 0x4B:  # PHK (Push Program Bank)
            self.push_stack(self.pb)
        elif opcode == 0x0B:  # PHD (Push Direct Page)
            if not self.emulation_mode:
                self.push_stack(self.d >> 8)
            self.push_stack(self.d & 0xFF)
        elif opcode == 0x2B:  # PLD (Pull Direct Page)
            if not self.emulation_mode:
                self.d = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.d = self.pop_stack()

        # Flag-Befehle
        # ... (CLC, SEC, CLI, SEI, CLV, CLD, SED wie zuvor)

        # Register-Transfers
        # ... (TAX, TAY, TXA, TYA, TSX wie zuvor)

        # Speicher-Transfers
        # ... (MVN, MVP wie zuvor)

        # Test-Befehle
        # ... (BIT, BRA wie zuvor)
        elif opcode == 0x89:  # BIT (immediate)
            value = self.memory[immediate()]
            result = self.a & value
            self.set_flag(0x02, result == 0)  # Zero Flag
            self.set_flag(0x80, value & 0x80)  # Negative Flag
            self.set_flag(0x40, value & 0x40)  # Overflow Flag

        # Branch-Befehle
        # ... (BCC, BCS, BEQ, BNE, BMI, BPL, BVC, BVS wie zuvor)

        # JMP (absolute)
        elif opcode == 0x4C:  # JMP (absolute)
            self.pc = absolute()
        elif opcode == 0x6C:  # JMP (indirect)
            address = absolute()
            self.pc = (self.memory[address + 1] << 8) | self.memory[address]

        # JSR, RTS, RTI
        # ... (JSR, RTS, RTI wie zuvor)

        # ... (Fortsetzung in Teil 13)
        # ... (Opcodes aus Teil 1-10)

        # Stack-relative Adressierung
        elif opcode == 0x61:  # ADC (indirect,X)
            address = indirect_x()
            value = self.memory[address]
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 == 0) and ((self.a ^ result) & 0x80 != 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        elif opcode == 0x71:  # ADC (indirect),Y
            address = indirect_y()
            value = self.memory[address]
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 == 0) and ((self.a ^ result) & 0x80 != 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        # ... (AND (indirect,X), (indirect),Y, CMP (indirect,X), (indirect),Y, EOR (indirect,X), (indirect),Y, LDA (indirect,X), (indirect),Y, ORA (indirect,X), (indirect),Y, SBC (indirect,X), (indirect),Y, STA (indirect,X), (indirect),Y)

        # Block Move-Befehle
        elif opcode == 0x54:  # MVN
            dest_bank = self.memory[immediate()]
            src_bank = self.memory[immediate()]
            count = self.memory[immediate()]
            for i in range(count + 1):
                self.memory[(dest_bank << 16) | self.y] = self.memory[(src_bank << 16) | self.x]
                self.y = (self.y + 1) & 0xFF
        elif opcode == 0x44:  # MVP
            dest_pos = self.memory[immediate()]
            src_pos = self.memory[immediate()]
            count = self.memory[immediate()]
            for i in range(count + 1):
                self.memory[dest_pos | self.a] = self.memory[src_pos | self.a]
                self.a = (self.a - 1) & 0xFF

        # Co-Prozessor-Befehle (nicht implementiert)
        elif opcode in range(0x00, 0x20) or opcode in range(0x40, 0x60) or opcode in range(0x80, 0xA0) or opcode in range(0xC0, 0xE0):
            pass  # Nicht implementiert

        # BCD-Arithmetik (nicht implementiert)
        # ... (XBA wie zuvor)

        # JSL (Jump to Subroutine Long)
        elif opcode == 0x22:
            low_byte = self.memory[self.pc]
            self.pc += 1
            mid_byte = self.memory[self.pc]
            self.pc += 1
            high_byte = self.memory[self.pc]
            self.pc += 1
            return_address = self.pc - 1
            self.push_stack(return_address >> 16)
            self.push_stack((return_address >> 8) & 0xFF)
            self.push_stack(return_address & 0xFF)
            self.pc = (high_byte << 16) | (mid_byte << 8) | low_byte

        # JSR (absolute,X)
        elif opcode == 0xFC:
            address = absolute_x()
            self.push_stack((self.pc - 1) >> 8)
            self.push_stack((self.pc - 1) & 0xFF)
            self.pc = address

        # ... (Fortsetzung in Teil 12)
# ... (Opcodes aus Teil 1-11)

        # Stack-Operationen
        elif opcode == 0x48:  # PHA
            self.push_stack(self.a)
        elif opcode == 0xDA:  # PHA (long)
            if not self.emulation_mode:
                self.push_stack(self.a >> 8)
            self.push_stack(self.a & 0xFF)
        elif opcode == 0x68:  # PLA
            self.a = self.pop_stack()
            self.set_zn_flags(self.a)
        elif opcode == 0xFA:  # PLA (long)
            if not self.emulation_mode:
                self.a = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.a = self.pop_stack()
            self.set_zn_flags(self.a)
        elif opcode == 0x08:  # PHP
            self.push_stack(self.p | 0x10 | 0x20)  # Break and unused flags gesetzt
        elif opcode == 0x28:  # PLP
            self.p = self.pop_stack() & 0xEF | 0x20  # Break-Flag löschen
        elif opcode == 0x5A:  # PHY (Push Y)
            if not self.emulation_mode:
                self.push_stack(self.y >> 8)
            self.push_stack(self.y & 0xFF)
        elif opcode == 0x7A:  # PLY (Pull Y)
            if not self.emulation_mode:
                self.y = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.y = self.pop_stack()
            self.set_zn_flags(self.y)
        elif opcode == 0x4B:  # PHK (Push Program Bank)
            self.push_stack(self.pb)
        elif opcode == 0x0B:  # PHD (Push Direct Page)
            if not self.emulation_mode:
                self.push_stack(self.d >> 8)
            self.push_stack(self.d & 0xFF)
        elif opcode == 0x2B:  # PLD (Pull Direct Page)
            if not self.emulation_mode:
                self.d = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.d = self.pop_stack()
        elif opcode == 0xAA:  # TAX
            self.x = self.a
            self.set_zn_flags(self.x)
        elif opcode == 0xA8:  # TAY
            self.y = self.a
            self.set_zn_flags(self.y)
        elif opcode == 0x8A:  # TXA
            self.a = self.x
            self.set_zn_flags(self.a)
        elif opcode == 0x98:  # TYA
            self.a = self.y
            self.set_zn_flags(self.a)

        # Bitverschiebungen und Rotationen
        elif opcode == 0x0A:  # ASL A
            self.c_flag = (self.a >> 7) & 1
            self.a = (self.a << 1) & 0xFF
            self.set_zn_flags(self.a)
        # ... (ASL, LSR, ROL, ROR für Zero Page, Zero Page,X, Absolute, Absolute,X)

        # Arithmetik und Logik mit Carry
        elif opcode == 0x69:  # ADC immediate
            # ... (Implementierung wie in Teil 7)
        elif opcode == 0xE9:  # SBC immediate
            # ... (Implementierung wie in Teil 7)

        # Vergleiche und Tests
        # ... (CMP, CPX, CPY, BIT wie in Teil 10)

        # Sprünge und Unterprogrammaufrufe
        # ... (JMP, JSR, RTS, RTI wie in Teil 11)

        # ... (Fortsetzung in Teil 13)


   

# ... (Opcodes aus Teil 1-12)

        # Bit-Manipulation
        elif opcode == 0x0A:  # ASL A
            self.c_flag = (self.a >> 7) & 1
            self.a = (self.a << 1) & 0xFF
            self.set_zn_flags(self.a)
        # ... (ASL, LSR, ROL, ROR für Zero Page, Zero Page,X, Absolute, Absolute,X)

        # Arithmetik
        elif opcode == 0x69:  # ADC immediate
            # ... (Implementierung wie in Teil 7)
        elif opcode == 0xE9:  # SBC immediate
            # ... (Implementierung wie in Teil 7)

        # Schieben und Rotieren
        # ... (ASL, LSR, ROL, ROR für Accumulator und Speicheradressen)

        # Vergleichen und Testen
        # ... (CMP, CPX, CPY, BIT wie in Teil 10)

        # Inkrement/Dekrement
        # ... (INC, INX, INY, DEC, DEX, DEY wie in Teil 3)

        # Transfer zwischen Registern
        # ... (TAX, TAY, TXA, TYA, TSX wie in Teil 12)

        # Laden und Speichern
        # ... (LDA, LDX, LDY, STA, STX, STY, STZ wie in Teil 1 und 2)

        # Sprünge und Aufrufe
        # ... (JMP, JSR, RTS, RTI wie in Teil 11 und 12)

        # Stack-Operationen
        # ... (PHA, PLA, PHP, PLP, PHY, PLY, PHK, PHD, PLD wie in Teil 12)

        # Dezimalmodus-Anweisungen
        elif opcode == 0xD8:  # CLD (Clear Decimal Mode)
            self.d_flag = 0
        elif opcode == 0xF8:  # SED (Set Decimal Mode)
            self.d_flag = 1

        # Statusregister-Operationen
        # ... (CLC, SEC, CLI, SEI, CLV wie in Teil 9)

        # Systemfunktionen
        elif opcode == 0x00:  # BRK
            # ... (Implementierung wie in Teil 9)
        elif opcode == 0x02:  # COP (Co-Processor Emulation)
            # Ignorieren, da wir keinen Co-Prozessor emulieren
            pass
        elif opcode == 0xDB:  # STP (Stop the Clock)
            raise StopIteration("STP-Opcode ausgeführt") # Beendet die Emulationsschleife

        # Ungültige und undokumentierte Opcodes
        # ... (WDM, MB, SMB, XBA wie in Teil 9 und 11)

        else:
            raise NotImplementedError(f"Opcode {hex(opcode)} not implemented yet")

        # ... (Zyklen zählen und Interrupts prüfen wie zuvor)
# ... (Opcodes aus Teil 1-11)

# ... (Stack-Operationen, Flag-Befehle, Register-Transfers, Speicher-Transfers, Test-Befehle, Branch-Befehle, JMP, JSR, RTS, RTI wie in Teil 11)

# Ungewöhnliche/Illegale Opcodes
elif opcode == 0xEB:  # SBC (immediate, aber wie 0xE9)
    value = self.memory[immediate()] ^ 0xFF  # Komplement für Subtraktion
    result = self.a + value + self.c_flag
    self.a = result & 0xFF
    self.set_flag(0x01, result > 0xFF)  # Carry Flag
    self.set_flag(0x40, ((self.a ^ value) & 0x80 != 0) and ((self.a ^ result) & 0x80 == 0))  # Overflow Flag
    self.set_zn_flags(self.a)
elif opcode == 0x0B or opcode == 0x2B:  # ANC (AND #, dann C = N)
    value = self.memory[immediate()]
    self.a &= value
    self.set_flag(0x01, self.n_flag)
    self.set_zn_flags(self.a)
elif opcode == 0x8B:  # XAA (Undokumentiert)
    self.a = ((self.a | 0xEE) & self.x) & self.memory[immediate()]
    self.set_zn_flags(self.a)
# ... (Implementierung weiterer ungewöhnlicher/illegaler Opcodes)

else:
    raise NotImplementedError(f"Opcode {hex(opcode)} not implemented yet")

# ... (Zyklen zählen und Interrupts prüfen wie zuvor)
# ... (Opcodes aus Teil 1-12)

        # Transfer-Befehle zwischen Registern
        elif opcode == 0xAA:  # TAX
            self.x = self.a
            self.set_zn_flags(self.x)
        elif opcode == 0xA8:  # TAY
            self.y = self.a
            self.set_zn_flags(self.y)
        elif opcode == 0x8A:  # TXA
            self.a = self.x
            self.set_zn_flags(self.a)
        elif opcode == 0x98:  # TYA
            self.a = self.y
            self.set_zn_flags(self.a)

        # Stack-Operationen
        # ... (PHA, PLA, PHP, PLP, PHY, PLY, PHK, PHD, PLD wie in Teil 12)

        # Dezimalmodus-Anweisungen
        elif opcode == 0xD8:  # CLD
            self.d_flag = 0
        elif opcode == 0xF8:  # SED
            self.d_flag = 1

        # Statusregister-Operationen
        elif opcode == 0x18:  # CLC
            self.c_flag = 0
        elif opcode == 0x38:  # SEC
            self.c_flag = 1
        elif opcode == 0x58:  # CLI
            self.i_flag = 0
        elif opcode == 0x78:  # SEI
            self.i_flag = 1
        elif opcode == 0xB8:  # CLV
            self.v_flag = 0

        # Systemfunktionen
        elif opcode == 0x00:  # BRK
            self.pc += 1
            self.push_stack(self.pc >> 8)
            self.push_stack(self.pc & 0xFF)
            self.push_stack(self.p | 0x10 | 0x20)  # Break and unused flags gesetzt
            self.i_flag = 1  # Interrupts deaktivieren
            self.pc = (self.memory[0xFFFE] << 8) | self.memory[0xFFFF]
        elif opcode == 0x02:  # COP (Co-Processor Emulation)
            # Ignorieren, da wir keinen Co-Prozessor emulieren
            pass
        elif opcode == 0xDB:  # STP (Stop the Clock)
            raise StopIteration("STP-Opcode ausgeführt") # Beendet die Emulationsschleife
        elif opcode == 0x42:  # WDM
            pass  # Nicht implementiert

        # ... (Fortsetzung in Teil 14)
        
# ... (Opcodes aus Teil 1-13)

        # Ungewöhnliche/Illegale Opcodes
        elif opcode == 0xEB:  # SBC (immediate, aber wie 0xE9)
            value = self.memory[immediate()] ^ 0xFF  # Komplement für Subtraktion
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 != 0) and ((self.a ^ result) & 0x80 == 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        elif opcode == 0x0B or opcode == 0x2B:  # ANC (AND #, dann C = N)
            value = self.memory[immediate()]
            self.a &= value
            self.set_flag(0x01, self.n_flag)
            self.set_zn_flags(self.a)
        elif opcode == 0x8B:  # XAA (Undokumentiert)
            self.a = ((self.a | 0xEE) & self.x) & self.memory[immediate()]
            self.set_zn_flags(self.a)
        elif opcode == 0xAB:  # LAX (immediate)  
            value = self.memory[immediate()]
            self.a = value
            self.x = value
            self.set_zn_flags(value)
        elif opcode == 0x9B:  # TAS (Transfer A to Stack pointer, then decrement Stack pointer)
            if not self.emulation_mode:
                self.s = self.a
                self.memory[0x100 + self.s] = self.a & self.x
                self.s -= 1
            else:
                self.s = self.a & 0xFF
                self.memory[0x100 + self.s] = (self.a & self.x) & 0xFF
                self.s -= 1
        elif opcode == 0xBB:  # LAS (Load Accumulator,X, and Stack pointer from memory)
            address = absolute_y()
            value = self.memory[address] & self.s
            self.a = value
            self.x = value
            self.s = value
            self.set_zn_flags(value)
        elif opcode == 0x93:  # AHX (absolute,Y)
            address = absolute_y() & 0xFFFF
            self.memory[address] = (self.a & self.x) & ((address >> 8) + 1)
        elif opcode == 0x9F:  # AHX (absolute,Y) with wrapping
            address = absolute_y()
            self.memory[address & 0xFFFF] = (self.a & self.x) & ((address >> 8) + 1)
        elif opcode == 0x9E:  # SHX (absolute,Y)
            address = absolute_y() & 0xFFFF
            self.memory[address] = self.x & ((address >> 8) + 1)
        elif opcode == 0x9B:  # SHY (absolute,X)
            address = absolute_x() & 0xFFFF
            self.memory[address] = self.y & ((address >> 8) + 1)

        # Fehlerbehandlung für nicht implementierte Opcodes
        else:
            raise NotImplementedError(f"Opcode {hex(opcode)} not implemented yet")

        # ... (Zyklen zählen und Interrupts prüfen wie zuvor)
        
# ... (Opcodes aus Teil 1-12)

        # Stack-Operationen
        elif opcode == 0x48:  # PHA
            self.push_stack(self.a)
        elif opcode == 0xDA:  # PHA (long)
            if not self.emulation_mode:
                self.push_stack(self.a >> 8)
            self.push_stack(self.a & 0xFF)
        elif opcode == 0x68:  # PLA
            self.a = self.pop_stack()
            self.set_zn_flags(self.a)
        elif opcode == 0xFA:  # PLA (long)
            if not self.emulation_mode:
                self.a = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.a = self.pop_stack()
            self.set_zn_flags(self.a)
        elif opcode == 0x08:  # PHP
            self.push_stack(self.p | 0x10 | 0x20)  # Break and unused flags gesetzt
        elif opcode == 0x28:  # PLP
            self.p = self.pop_stack() & 0xEF | 0x20  # Break-Flag löschen
        elif opcode == 0x5A:  # PHY (Push Y)
            if not self.emulation_mode:
                self.push_stack(self.y >> 8)
            self.push_stack(self.y & 0xFF)
        elif opcode == 0x7A:  # PLY (Pull Y)
            if not self.emulation_mode:
                self.y = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.y = self.pop_stack()
            self.set_zn_flags(self.y)
        elif opcode == 0x4B:  # PHK (Push Program Bank)
            self.push_stack(self.pb)
        elif opcode == 0x0B:  # PHD (Push Direct Page)
            if not self.emulation_mode:
                self.push_stack(self.d >> 8)
            self.push_stack(self.d & 0xFF)
        elif opcode == 0x2B:  # PLD (Pull Direct Page)
            if not self.emulation_mode:
                self.d = (self.pop_stack() << 8) | self.pop_stack()
            else:
                self.d = self.pop_stack()
        elif opcode == 0x8B:  # PHB (Push Data Bank)
            self.push_stack(self.db)
        elif opcode == 0xAB:  # PLB (Pull Data Bank)
            self.db = self.pop_stack()
        elif opcode == 0x6B:  # RTL (Return from Subroutine Long)
            low_byte = self.pop_stack()
            mid_byte = self.pop_stack()
            high_byte = self.pop_stack()
            self.pc = (high_byte << 16) | (mid_byte << 8) | low_byte
            self.pc += 1
        elif opcode == 0x62:  # PER (Push Effective Relative address)
            address = absolute()
            relative_address = (address - self.pc + 1) & 0xFFFF
            self.push_stack(relative_address >> 8)
            self.push_stack(relative_address & 0xFF)

        # Flag-Befehle
        # ... (CLC, SEC, CLI, SEI, CLV, CLD, SED wie zuvor)

        # Register-Transfers
        # ... (TAX, TAY, TXA, TYA, TSX wie zuvor)

        # Speicher-Transfers
        # ... (MVN, MVP wie zuvor)

        # Test-Befehle
        # ... (BIT, BRA wie zuvor)

        # Branch-Befehle
        # ... (BCC, BCS, BEQ, BNE, BMI, BPL, BVC, BVS wie zuvor)

        # JMP (absolute)
        # ... (JMP (absolute), JMP (indirect) wie zuvor)

        # JSR, RTS, RTI
        # ... (JSR, RTS, RTI wie zuvor)

        # WAI, STP
        elif opcode == 0xCB:  # WAI (Wait for Interrupt)
            self.waiting = True
            # Hier müsstest du die Emulation anhalten, bis ein Interrupt auftritt
        elif opcode == 0xDB:  # STP (Stop the Clock)
            raise StopIteration("STP-Opcode ausgeführt") # Beendet die Emulationsschleife
        
        # ... (Fortsetzung in Teil 14)
# ... (Opcodes aus Teil 1-13)

        # Ungewöhnliche/Illegale Opcodes
        elif opcode == 0xEB:  # SBC (immediate, aber wie 0xE9)
            value = self.memory[immediate()] ^ 0xFF  # Komplement für Subtraktion
            result = self.a + value + self.c_flag
            self.a = result & 0xFF
            self.set_flag(0x01, result > 0xFF)  # Carry Flag
            self.set_flag(0x40, ((self.a ^ value) & 0x80 != 0) and ((self.a ^ result) & 0x80 == 0))  # Overflow Flag
            self.set_zn_flags(self.a)
        elif opcode == 0x0B or opcode == 0x2B:  # ANC (AND #, dann C = N)
            value = self.memory[immediate()]
            self.a &= value
            self.set_flag(0x01, self.n_flag)
            self.set_zn_flags(self.a)
        elif opcode == 0x8B:  # XAA (Undokumentiert)
            self.a = ((self.a | 0xEE) & self.x) & self.memory[immediate()]
            self.set_zn_flags(self.a)
        elif opcode == 0xAB:  # LAX (immediate)  
            value = self.memory[immediate()]
            self.a = value
            self.x = value
            self.set_zn_flags(value)
        elif opcode == 0x9B:  # TAS (Transfer A to Stack pointer, then decrement Stack pointer)
            if not self.emulation_mode:
                self.s = self.a
                self.memory[0x100 + self.s] = self.a & self.x
                self.s -= 1
            else:
                self.s = self.a & 0xFF
                self.memory[0x100 + self.s] = (self.a & self.x) & 0xFF
                self.s -= 1
        elif opcode == 0xBB:  # LAS (Load Accumulator,X, and Stack pointer from memory)
            address = absolute_y()
            value = self.memory[address] & self.s
            self.a = value
            self.x = value
            self.s = value
            self.set_zn_flags(value)
        elif opcode == 0x93:  # AHX (absolute,Y)
            address = absolute_y() & 0xFFFF
            self.memory[address] = (self.a & self.x) & ((address >> 8) + 1)
        elif opcode == 0x9F:  # AHX (absolute,Y) with wrapping
            address = absolute_y()
            self.memory[address & 0xFFFF] = (self.a & self.x) & ((address >> 8) + 1)
        elif opcode == 0x9E:  # SHX (absolute,Y)
            address = absolute_y() & 0xFFFF
            self.memory[address] = self.x & ((address >> 8) + 1)
        elif opcode == 0x9B:  # SHY (absolute,X)
            address = absolute_x() & 0xFFFF
            self.memory[address] = self.y & ((address >> 8) + 1)

        # Fehlerbehandlung für nicht implementierte Opcodes
        else:
            raise NotImplementedError(f"Opcode {hex(opcode)} not implemented yet")

        # ... (Zyklen zählen und Interrupts prüfen wie zuvor)
